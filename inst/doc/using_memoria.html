<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Blas M. Benito" />


<title>Using “memoria” and “virtualPollen” together</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Using “memoria” and “virtualPollen” together</h1>
<h3 class="subtitle">Quantifying ecological memory of virtual pollen curves</h3>
<h4 class="author">Blas M. Benito</h4>



<!-- --- -->
<!-- title: 'Using "memoria" and "virtualPollen" together' -->
<!-- subtitle: 'Quantifying ecological memory of virtual pollen curves' -->
<!-- author: "Blas M. Benito" -->
<!-- output: -->
<!--   pdf_document:  -->
<!--     df_print: kable -->
<!--     fig_caption: yes -->
<!--     fig_width: 9 -->
<!--     highlight: tango -->
<!--     includes: -->
<!--       in_header: header.tex -->
<!--     keep_tex: yes -->
<!--     latex_engine: xelatex -->
<!--     number_sections: yes -->
<!--     toc: yes -->
<!--     toc_depth: 2 -->
<!-- code_folding: show -->
<!-- --- -->
<!-- knit_hooks$set(document  =  function(x) {sub('\\usepackage[]{color}', '\\usepackage{xcolor}', x, fixed = TRUE)}) -->
<!-- main info on pdf and notebooks -->
<!-- http://rmarkdown.rstudio.com/pdf_document_format.html#latex_engine -->
<!-- check xelatex fonts -->
<!-- fc-list : family -->
<!-- fc-list :fontformat = TrueType -->
<!-- Equations cheatsheet -->
<!-- $a_{b}$ -->
<!-- $a^{b}$ -->
<!-- $\alpha, \beta, \ldots$ -->
<!-- $\sum_{n = 1}^N$ -->
<!-- $\times$ -->
<!-- $\prod_{n = 1}^N$ -->
<!-- $<, \leq, \geq$ -->
<!-- $\sim$ -->
<!-- $\widehat{\alpha}$ -->
<!-- $\bar{x}$ -->
<!-- $\frac{a}{b}$ -->
<!-- $\left(\frac{a}{b}\right)$ -->
<p><strong>Summary</strong></p>
<p>This document describes in detail how to analyze ecological memory patterns present in simulated pollen curves generated with the <em>virtualPollen</em> and <em>memoria</em> packages. First, we describe the complex statistical properties of the virtual pollen curves produced by <em>virtualPollen</em> and how these may impact ecological memory analyses; Second we explain how Random Forest works, from its basic components (regression trees) to the way in which it computes variable importance; Third, we explain how to analyze ecological memory patterns on the simulation outputs.</p>

<div id="the-model" class="section level1">
<h1>The model</h1>
<p>Analyzing ecological memory requires to fit a model of the form:</p>
<p><strong>Equation 1</strong> (simplified from the one in the paper): <span class="math display">\[p_{t} = p_{t-1} +...+ p_{t-n} + d_{t} + d_{t-1} +...+ d_{t-n}\]</span> </p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(p\)</span> is <em>Pollen</em>.</li>
<li><span class="math inline">\(d\)</span> is <em>Driver</em>.</li>
<li><span class="math inline">\(t\)</span> is the time of any given value of the response <span class="math inline">\(p\)</span>.</li>
<li><span class="math inline">\(t-1\)</span> is the lag 1.</li>
<li><span class="math inline">\(p_{t-1} +...+ p_{t-n}\)</span> represents the endogenous component of ecological memory.</li>
<li><span class="math inline">\(d_{t-1} +...+ d_{t-n}\)</span> represents the exogenous component of ecological memory.</li>
<li><span class="math inline">\(d_{t}\)</span> represents the concurrent effect of the driver over the response.</li>
</ul>
<p>The function <em>prepareLaggedData</em> shown below organizes the input data in <em>lags</em>. It requires to identify what columns in the original data should act as response, drivers, and time, and what lags are to be generated.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">#loading data</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span>(simulation) <span class="co">#from virtualPollen</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">sim &lt;-<span class="st"> </span>simulation[[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="co">#generating vector of lags (same as in paper)</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">lags &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">20</span>, <span class="dv">240</span>, <span class="dt">by =</span> <span class="dv">20</span>)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="co">#organizing data in lags</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">sim.lags &lt;-<span class="st"> </span><span class="kw">prepareLaggedData</span>(</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="dt">input.data =</span> sim,</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="dt">response =</span> <span class="st">&quot;Pollen&quot;</span>,</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="dt">drivers =</span> <span class="kw">c</span>(<span class="st">&quot;Driver.A&quot;</span>, <span class="st">&quot;Suitability&quot;</span>),</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="dt">time =</span> <span class="st">&quot;Time&quot;</span>,</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  <span class="dt">lags =</span> lags,</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  <span class="dt">scale =</span> <span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  )</a></code></pre></div>
<p>This function returns the data shown in <strong>Table 1</strong>. This kind of data structure is known as <em>lagged data</em> or <em>time delayed data</em>. Note that the function can use a <em>scale</em> argument (set to FALSE above) to standardize the data before generating the lags. Random Forest does not generally require standardization to fit accurate models of the data, but computing variable importance with variables having large differences in range (i.e. [1, 10] vs. [1, 10000]) might yield biased results, making standardization a recommended step in data preparation. In this appendix all data are shown without any standardization to let the reader to keep track of the different variables across analyses and have a sense of their magnitude, but note that all analyses presented in the paper were based on standardized data.</p>
<p>The data in <strong>Table 1</strong> are organized to fit the model described by <strong>Equation 1</strong>, but to select a proper method to fit the model, three main features of the data have to be considered first: <strong>temporal autocorrelation</strong>, <strong>multicollinearity</strong>, and <strong>non-linearity</strong>.</p>
</div>
<div id="the-data" class="section level1">
<h1>The data</h1>
<p>The simulations produced by <em>virtualPollen</em> have some key properties that justify the use of Random Forest as analytical tool.</p>
<div id="temporal-autocorrelation" class="section level2">
<h2>Temporal autocorrelation</h2>
<p>Temporal autocorrelation (also <em>serial correlation</em>) refers to the relationship between successive values of the same variable present in most time series. Temporal autocorrelation generates autocorrelated residuals in regression analysis, violating the assumption of “independence of errors” required to correctly interpret regression coefficients. Several methods can be used to address temporal autocorrelation in regression analysis, such as increasing time intervals between consecutive samples, or incorporating an auto-regressive structure into the model.</p>
<p>Every variable used in our study presents this characteristic. The driver was generated with a temporal autocorrelation significant for periods of 600 years. The suitability produced by the niche function of the virtual taxa based on the values of the driver also presents temporal autocorrelation, but generally lower than the one of the driver. Finally, the response, since it is the result of a dynamic model in which every data-point depends on the previous one, also shows a temporal structure, which varies depending on the taxa’s traits, as so does the suitability (see <strong>Figure 2</strong>).</p>
</div>
<div id="multicollinearity" class="section level2">
<h2>Multicollinearity</h2>
<p>Multicollinearity occurs when there is a high correlation between predictors in a model definition. It increases the standard error of the coefficients, meaning that their estimates for important predictors can become statistically insignificant, wildly impacting model interpretation.</p>
<p>Adding consecutive time-lags of the same variables to the data, as required by the model expressed in <strong>Equation 1</strong> largely increases multicollinearity.</p>

</div>
<div id="non-linearity" class="section level2">
<h2>Non-linearity</h2>
<p>The function <em>virtualPollen::simulatePopulation</em> has the ability to produce pollen abundances variably decoupled from environmental conditions depending on the life-traits and niche features of the virtual taxa considered. This model property increases the chance of finding non-linear relationships between time-lagged predictors and the response (see <strong>Figure 3</strong>), hindering the detection of meaningful relationships with methods not able to account for non-nonlinearity.</p>
</div>
</div>
<div id="the-logics-behind-random-forest" class="section level1">
<h1>The logics behind Random Forest</h1>
<div id="the-trees" class="section level2">
<h2>The trees</h2>
<p>The fundamental units of a Random Forest model are <strong>regression trees</strong>. A regression tree grows through <strong>binary recursive partition</strong>. Considering a <em>response</em> variable, and a set of <em>predictive variables</em> (also named <em>features</em> in the machine learning language), the following steps grow a regression tree:</p>
<ul>
<li>For each variable, the point in their ranges that optimizes the separation (partition) of the response in two groups of cases is searched for. The selected point minimizes the sum of the squared deviations from the mean in the two separated partitions.</li>
<li>The variable with the lower sum of the squared deviations from the means is selected as the <em>root node</em> of the tree, and the data are separated in two partitions, one on each side of the <em>split value</em> of the given variable.</li>
<li>The steps above are recursively applied to each partition to create new partitions, until all cases are in partitions that can be no longer separated in smaller partitions because they are too homogeneous, or because they have reached a minimum sample size. These final partitions are named <em>terminal nodes</em>.</li>
</ul>
<p>The code below shows how to fit a recursive partition tree with the <em>rpart</em> library on the first lag (20 years) of pollen and driver of the data shown in <strong>Figure 2</strong>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">#fitting model (only two predictors)</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">rpart.model &lt;-<span class="st"> </span><span class="kw">rpart</span>(</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="dt">formula =</span> Response_<span class="dv">0</span> <span class="op">~</span><span class="st"> </span>Response_<span class="dv">20</span> <span class="op">+</span><span class="st"> </span>Driver.A_<span class="dv">20</span>,</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="dt">data =</span> sim.lags,</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="dt">control =</span> <span class="kw">rpart.control</span>(<span class="dt">minbucket =</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  )</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co">#plotting tree</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">rpart.plot</span>(</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  rpart.model, </a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  <span class="dt">type =</span> <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  <span class="dt">box.palette =</span> <span class="kw">viridis</span>(<span class="dv">10</span>, <span class="dt">alpha =</span> <span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  )</a></code></pre></div>
<p><strong>Figure 4</strong> shows the recursive partition tree fitted on Pollen_0 as a function of the first lag of pollen (Pollen_20) and the driver (Driver_20), while <strong>Figure 5</strong> shows the partitions in the space of both variables. As shown in both figures, the recursive partition tree is, in essence, separating the cases into regions in which given combinations of the predictors lead to certain average values of the response. The tree also shows the hierarchy in importance between both predictors, with <em>Pollen_20</em> defining all splits but one. Only when <em>Pollen_20</em> is higher than 3772, the variable <em>Driver_20</em> becomes important, indicating that maximum abundances are only reached after that point, and only if <em>Driver_20</em> has a value lower than 71. This is how partial interactions among predictors are expressed in recursive partition trees.</p>
<p>The tree has grown until data in the terminal nodes cannot be separated further into additional partitions, or has reached the minimum number of cases defined by the variable <em>minbucket</em>. The minimum amount of cases in a terminal node defines the overall resolution of the model. Smaller numbers lead to a higher amount of terminal nodes, and therefore to more partitions in the data space. This can be confirmed by changing the <em>minbucket</em> value in the code above, and assessing subsequent changes in tree structure and number of partitions.</p>
<p>As a drawback, the splits of a recursive partition trees are highly sensitive to small changes in the input data, specially when sample size is small. This instability has led to the development of more sophisticated methods to fit recursive partition trees, such as <em>conditional inference trees</em> (see function <em>ctree</em> in library <em>partykit</em>), or ensemble methods such as Random Forest.</p>
</div>
<div id="the-forest" class="section level2">
<h2>The forest</h2>
<p>A Random Forest model is composed by a large number of individual regression trees (500 or more) generated on random subsamples of the predictors and the cases. For a random set of cases, each tree is fitted as follows:</p>
<ul>
<li>A random subset of predictors of size <em>mtry</em> is selected. The default <em>mtry</em> is the rounded-up squared root of the total number of predictors, but the user can modify it.</li>
<li>The predictor from the random subset that better separates the data into two partitions is selected as <em>root node</em>, an the data are separated in two partitions, one at each side of the <em>split value</em>.</li>
<li>On each partition, a new random subset of predictors of size <em>mtry</em> is selected (and this is the main difference between a recursive partition tree and a Random Forest tree, the former uses all variables on each split), and again the predictor that better separates the partition into two new partitions is selected, and new partitions are defined.</li>
<li>The tree is grown until minimum node size is reached in all terminal nodes, or no further partitions can be defined.</li>
<li>The tree is evaluated by computing its mean squared error (mse) on the ~37% of the data not used to train it (named <em>out-of-bag data</em>).</li>
<li>For each variable in the tree the algorithm performs a permutation test as follows:
<ul>
<li>The column with the given variable is randomly permuted.</li>
<li>A new tree is fitted with the permuted variable.</li>
<li>Mean squared error is computed again on the <em>out-of-bag</em> data.</li>
<li>Difference in mse between the tree fitted with the original variable and the tree fitted with the permuted one is computed and stored.</li>
</ul></li>
</ul>
<p>Once all trees have been fitted, for every given case, the prediction is computed as the mode of the individual predictions of every tree (but not the ones fitted with permuted variables). The importance of every variable is computed as the average of the differences in mean squared error between trees computed with the variable and trees computed with the permuted variable, normalized by the standard deviation of the differences.</p>
<p>Random Forest does not require any assumptions to be fulfilled by the data or the model outcomes, and therefore it can be applied to a wide range of analytic cases where data are non-linear. As a drawback, the randomness in the selection of cases and predictors to fit individual regression trees turns it into a non-deterministic algorithm, and therefore, fine-scale variations in the outcomes are to be expected between different runs with the same data.</p>
<p>To fit Random Forest models on the simulated data we selected the package <em>ranger</em> over the more traditional <em>randomForest</em> because the former allows multithread computing (uses all available cores in a computer while fitting the forest), achieving a better performance for large datasets than the later. The code below shows how to use <em>ranger</em> to fit a Random Forest model.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">#getting columns containing &quot;Response&quot; or &quot;Driver&quot;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">sim.lags.rf &lt;-<span class="st"> </span>sim.lags[, <span class="kw">grepl</span>(<span class="st">&quot;Driver|Response&quot;</span>, <span class="kw">colnames</span>(sim.lags))]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">#fitting a Random Forest model</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">rf.model &lt;-<span class="st"> </span><span class="kw">ranger</span>(</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  <span class="dt">data =</span> sim.lags.rf,</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="dt">dependent.variable.name =</span> <span class="st">&quot;Response_0&quot;</span>,</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  <span class="dt">num.trees =</span> <span class="dv">500</span>,</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  <span class="dt">min.node.size =</span> <span class="dv">5</span>, </a>
<a class="sourceLine" id="cb3-10" data-line-number="10">  <span class="dt">mtry =</span> <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  <span class="dt">importance =</span> <span class="st">&quot;permutation&quot;</span>, </a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  <span class="dt">scale.permutation.importance =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="co">#model summary</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="kw">print</span>(rf.model)</a>
<a class="sourceLine" id="cb3-16" data-line-number="16"></a>
<a class="sourceLine" id="cb3-17" data-line-number="17"><span class="co">#R-squared (computed on out-of-bag data)</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">rf.model<span class="op">$</span>r.squared</a>
<a class="sourceLine" id="cb3-19" data-line-number="19"></a>
<a class="sourceLine" id="cb3-20" data-line-number="20"><span class="co">#variable importance</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">rf.model<span class="op">$</span>variable.importance</a>
<a class="sourceLine" id="cb3-22" data-line-number="22"></a>
<a class="sourceLine" id="cb3-23" data-line-number="23"><span class="co">#obtain case predictions</span></a>
<a class="sourceLine" id="cb3-24" data-line-number="24">rf.model<span class="op">$</span>predictions</a>
<a class="sourceLine" id="cb3-25" data-line-number="25"></a>
<a class="sourceLine" id="cb3-26" data-line-number="26"><span class="co">#getting information of the first tree</span></a>
<a class="sourceLine" id="cb3-27" data-line-number="27"><span class="kw">treeInfo</span>(rf.model, <span class="dt">tree=</span><span class="dv">1</span>)</a></code></pre></div>
<p>The function <em>ranger</em> has the following key arguments:</p>
<ul>
<li><strong>data</strong>: dataframe with the variables to be included in the model.</li>
<li><strong>dependent.variable.name</strong>: model definition can be done in two ways, either through a formula, or through the argument <em>dependent.variable.name</em>, that names the response variable, and uses the remaining variables in the dataset as predictors, which forces us to be careful with what variables are available in the dataset.</li>
<li><strong>num.trees</strong>: controls number of trees generated (the default value is 500).</li>
<li><strong>mtry</strong>: controls the number of variables randomly selected to fit each tree. In the code above this argument is set to 2, indicating that the model only considers interactions among two predictors only on each tree. This allows to compute variable importance as independently as possible from other variables.</li>
<li><strong>min.node.size</strong>: minimum number of cases in a terminal node, which determines the overall resolution of the model.</li>
<li><strong>importance</strong>: when set to “permutation” it triggers the computation of variable importance through permutation tests.</li>
<li><strong>scale.permutation.importance</strong>: scales importance values computed through the permutation tests by the overall standard error.</li>
</ul>
<p>The relationship between the response variable and the predictors can be examined through <em>partial dependence plots</em> (see <strong>Figure 6</strong>). A partial dependence plot is a simplified view of the inner structure of the model. Since regression trees consider interactions among variables, the prediction for any given case depends on the values of all predictors considered at the same time. Since it is not possible to generate such a representation in 2D or 3D, partial dependence plots set all variables not represented in the plot to their respective means. Therefore, partial dependence plots must be interpreted as simple approximations to the true shape of the model surface.</p>
<p>Interactions among predictors can be represented in the same way done before for recursive partition trees (see <strong>Figure 7</strong>). Again, all variables not represented in the plot are set to their average to generate the prediction.</p>
</div>
<div id="variable-importance" class="section level2">
<h2>Variable importance</h2>
<p>Random forest variable importance computation works under the assumption that if a given variable is not important, then permuting its values does not degrade the prediction accuracy. Variable importance scores are extracted with the <em>importance</em> function (see code below and <strong>Table 4</strong>), and are interpreted as “how much model fit degrades when the given variable is removed from the model”.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">importance</span>(rf.model)</a></code></pre></div>
<p>Values shown in <strong>Table 4</strong> are the result of one particular Random Forest run. For variables with small differences in importance, the ranking shown in the table could change in a different model run. This situation can be addressed by running the model several times, and computing the average and confidence intervals of the importance scores of each predictor across runs. This is shown in the code below (see output in <strong>Figure 8</strong>).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">#number of repetitions</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">repetitions &lt;-<span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="co">#list to save importance results</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">importance.list &lt;-<span class="st"> </span><span class="kw">list</span>()</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="co">#repetitions</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>repetitions){</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="co">#fitting a Random Forest model</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  rf.model &lt;-<span class="st"> </span><span class="kw">ranger</span>(</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    <span class="dt">data =</span> sim.lags.rf,</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="dt">dependent.variable.name =</span> <span class="st">&quot;Response_0&quot;</span>,</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    <span class="dt">mtry =</span> <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">    <span class="dt">importance =</span> <span class="st">&quot;permutation&quot;</span>, </a>
<a class="sourceLine" id="cb5-16" data-line-number="16">    <span class="dt">scale.permutation.importance =</span> <span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    )</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">  <span class="co">#extracting importance</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">  importance.list[[i]] &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">t</span>(<span class="kw">importance</span>(rf.model)))</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">}</a>
<a class="sourceLine" id="cb5-22" data-line-number="22"></a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="co">#into a single dataframe</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24">importance.df &lt;-<span class="st"> </span><span class="kw">do.call</span>(<span class="st">&quot;rbind&quot;</span>, importance.list)</a></code></pre></div>


</div>
<div id="testing-the-significance-of-variable-importance-scores" class="section level2">
<h2>Testing the significance of variable importance scores</h2>
<p>Random Forest does not provide any tool to assess the significance of these importance scores, and it is therefore impossible to know at what point they become irrelevant. A simple solution is to add a random variable as an additional predictor to the model and compute its importance. If the importance of other variables is equal or lower than the importance of the random variable, it can be assumed that these variables do not have a meaningful effect on the response, and can therefore be considered irrelevant.</p>
<p>Two types of random variables can be considered to be used as benchmarks to test variable importance scores provided by Random Forest: <strong>white noise</strong> (without any temporal structure), and <strong>random walk with temporal structure</strong> (as explained in Appendix I). In both cases the idea is to generate a <em>null model</em> providing a baseline to assess to what extent importance scores are higher than what is expected by chance. To test the suitability of both methods, the code below generates 10 Random Forest models, each one with two additional random variables: <em>random.white</em> representing white noise, and <em>random.autocor</em> representing an autocorrelated random walk. The length of the autocorrelation period of <em>random.autocor</em> is changed for every iteration.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">#number of repetitions</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">repetitions &lt;-<span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co">#list to save importance results</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">importance.list &lt;-<span class="st"> </span><span class="kw">list</span>()</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="co">#rows of the input dataset</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">n.rows &lt;-<span class="st"> </span><span class="kw">nrow</span>(sim.lags.rf)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="co">#repetitions</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>repetitions){</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="co">#adding/replacing random.white column</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  sim.lags.rf<span class="op">$</span>random.white &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n.rows)</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb6-16" data-line-number="16">  <span class="co">#adding/replacing random.autocor column</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="co">#different filter length on each run = different temporal structure</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  sim.lags.rf<span class="op">$</span>random.autocor &lt;-<span class="st"> </span><span class="kw">as.vector</span>(</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    <span class="kw">filter</span>(<span class="kw">rnorm</span>(n.rows),</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">           <span class="dt">filter =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">floor</span>(n.rows<span class="op">/</span><span class="dv">4</span>), <span class="dv">1</span>)),</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">           <span class="dt">method =</span> <span class="st">&quot;convolution&quot;</span>,</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">           <span class="dt">circular =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb6-23" data-line-number="23"></a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="co">#fitting a Random Forest model</span></a>
<a class="sourceLine" id="cb6-25" data-line-number="25">  rf.model &lt;-<span class="st"> </span><span class="kw">ranger</span>(</a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    <span class="dt">data =</span> sim.lags.rf,</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    <span class="dt">dependent.variable.name =</span> <span class="st">&quot;Response_0&quot;</span>,</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    <span class="dt">mtry =</span> <span class="dv">2</span>,</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">    <span class="dt">importance =</span> <span class="st">&quot;permutation&quot;</span>, </a>
<a class="sourceLine" id="cb6-30" data-line-number="30">    <span class="dt">scale.permutation.importance =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb6-31" data-line-number="31"></a>
<a class="sourceLine" id="cb6-32" data-line-number="32">  <span class="co">#extracting importance</span></a>
<a class="sourceLine" id="cb6-33" data-line-number="33">  importance.list[[i]] &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">t</span>(<span class="kw">importance</span>(rf.model)))</a>
<a class="sourceLine" id="cb6-34" data-line-number="34">  </a>
<a class="sourceLine" id="cb6-35" data-line-number="35">}</a>
<a class="sourceLine" id="cb6-36" data-line-number="36"></a>
<a class="sourceLine" id="cb6-37" data-line-number="37"><span class="co">#into a single dataframe</span></a>
<a class="sourceLine" id="cb6-38" data-line-number="38">importance.df &lt;-<span class="st"> </span><span class="kw">do.call</span>(<span class="st">&quot;rbind&quot;</span>, importance.list)</a></code></pre></div>
<p>The boxplot in <strong>Figure 9</strong> shows the relative importance of the random variables, and suggests that the variable representing random noise is not useful to identify importance scores arising by chance. On the other hand, the variable based on autocorrelated random walks (marked in yellow in the plot) tells a different story. Importance values below the yellow solid line have a probability higher than 0.5 of being the result of chance. Importance values between the yellow solid and dashed lines have probabilities between 0.5 and 0 and are the result of a random association between a predictor and the response, while beyond the dashed line the results can be confidently defined as non-random. Note that <strong>Figure 8</strong>, when compared with <strong>Figure 7</strong>, also shows that adding random variables to a Random Forest model does not change the importance scores of other variables in the model.</p>
</div>
</div>
<div id="analyzing-ecological-memory-with-random-forest-and-the-memoria-library" class="section level1">
<h1>Analyzing ecological memory with Random Forest and the <em>memoria</em> library</h1>
<p>So far we have explained how to organize the simulated pollen curves in lags, and how to fit Random Forest models on the lagged data to evaluate variable importance. However, further steps are required to quantify ecological memory patterns:</p>
<ul>
<li>Extract and aggregate variable importance scores, and organize them in ecological memory components (endogenous, exogenous, and concurrent).</li>
<li>Plot the pattern to facilitate interpretation.</li>
<li>Extract ecological memory features from these components, namely <strong>memory strength</strong> (maximum difference in relative importance between each component (endogenous, exogenous, and concurrent) and the median of the random component), <strong>memory length</strong> (proportion of lags over which the importance of a memory component is above the median of the random component), and <strong>dominance</strong> (proportion of the lags above the median of the random term over which a memory component has a higher importance than the other component).</li>
</ul>
<p>The function <strong>computeMemory</strong> fits as many Random Forest models as indicated by the argument <em>repetitions</em> on a lagged dataset, and on each iteration includes a random variable in the model. The function <strong>plotMemory</strong> gets the output of <strong>computeMemory</strong> and plots it, while the function <em>extractMemoryFeatures</em> computes the features of each ecological memory component. The simplified workflow is shown below.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">#computes ecological memory pattern</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">memory.pattern &lt;-<span class="st"> </span><span class="kw">computeMemory</span>(</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="dt">lagged.data =</span> sim.lags, </a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="dt">drivers =</span> <span class="st">&quot;Driver.A&quot;</span>, </a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="dt">random.mode=</span><span class="st">&quot;autocorrelated&quot;</span>,</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="dt">repetitions=</span><span class="dv">30</span>, </a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="dt">response=</span><span class="st">&quot;Response&quot;</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  )</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="co">#computing memory features</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">memory.features &lt;-<span class="st"> </span><span class="kw">extractMemoryFeatures</span>(</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  <span class="dt">memory.pattern=</span>memory.pattern,</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="dt">exogenous.component=</span><span class="st">&quot;Driver.A&quot;</span>,</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  <span class="dt">endogenous.component=</span><span class="st">&quot;Response&quot;</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">  )</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"><span class="co">#plotting the ecological memory pattern</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18"><span class="kw">plotMemory</span>(memory.pattern)</a></code></pre></div>
<p>In order to analyze the ecological memory patterns of 16 virtual taxa across the 5 levels of data quality (Annual, 1cm, 2cm, 6cm, and 10cm), we integrated the functions above into a larger function named <em>runExperiment</em>. The code below runs an artificial simple example with only two virtual taxa (1 and 6 in <em>parameters</em>), and two dataset types (“1cm” and “10cm”). Only 30 repetitions are generated to quicken execution, which is not nearly enough to achieve consistent results.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">#running experiment</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">E1 &lt;-<span class="st"> </span><span class="kw">runExperiment</span>(</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="dt">simulations.file =</span> simulation,</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="dt">selected.rows =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>,</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">selected.columns =</span> <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="dt">parameters.file =</span> parameters,</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="dt">parameters.names =</span> <span class="kw">c</span>(<span class="st">&quot;maximum.age&quot;</span>,</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                       <span class="st">&quot;fecundity&quot;</span>,</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">                       <span class="st">&quot;niche.A.mean&quot;</span>,</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">                       <span class="st">&quot;niche.A.sd&quot;</span>),</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  <span class="dt">sampling.names =</span> <span class="st">&quot;1cm&quot;</span>,</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  <span class="dt">driver.column =</span> <span class="st">&quot;Driver.A&quot;</span>,</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  <span class="dt">response.column =</span> <span class="st">&quot;Pollen&quot;</span>,</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">  <span class="dt">time.column =</span> <span class="st">&quot;Time&quot;</span>,</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">  <span class="dt">lags =</span> lags,</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">  <span class="dt">repetitions =</span> <span class="dv">30</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  )</a>
<a class="sourceLine" id="cb8-18" data-line-number="18"></a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="co">#E1 is a list of lists</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20"><span class="co">#first list: names of experiment output</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">E1<span class="op">$</span>names </a>
<a class="sourceLine" id="cb8-22" data-line-number="22"></a>
<a class="sourceLine" id="cb8-23" data-line-number="23"><span class="co">#second list, first element</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">i &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co">#change to see other elements</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25"><span class="co">#ecological memory pattern</span></a>
<a class="sourceLine" id="cb8-26" data-line-number="26">E1<span class="op">$</span>output[[i]]<span class="op">$</span>memory</a>
<a class="sourceLine" id="cb8-27" data-line-number="27"></a>
<a class="sourceLine" id="cb8-28" data-line-number="28"><span class="co">#pseudo R-squared across repetitions</span></a>
<a class="sourceLine" id="cb8-29" data-line-number="29">E1<span class="op">$</span>output[[i]]<span class="op">$</span>R2</a>
<a class="sourceLine" id="cb8-30" data-line-number="30"></a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="co">#predicted pollen across repetitions</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32">E1<span class="op">$</span>output[[i]]<span class="op">$</span>prediction</a>
<a class="sourceLine" id="cb8-33" data-line-number="33"></a>
<a class="sourceLine" id="cb8-34" data-line-number="34"><span class="co">#variance inflation factor of input data</span></a>
<a class="sourceLine" id="cb8-35" data-line-number="35">E1<span class="op">$</span>output[[i]]<span class="op">$</span>multicollinearity</a></code></pre></div>
<p>Experiment results can be plotted with the function <em>plotExperiment</em> shown below.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">plotExperiment</span>(</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="dt">experiment.output=</span>E1,</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="dt">parameters.file=</span>parameters,</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="dt">experiment.title=</span><span class="st">&quot;Toy experiment&quot;</span>,</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="dt">sampling.names=</span><span class="kw">c</span>(<span class="st">&quot;1cm&quot;</span>, <span class="st">&quot;10cm&quot;</span>),</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="dt">legend.position=</span><span class="st">&quot;bottom&quot;</span>,</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="dt">R2=</span><span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  )</a></code></pre></div>
<p>The experiment data can be organizes as a single table, joined with the data available in the <em>parameters</em> dataframe to facilitate further analyses.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">E1.df &lt;-<span class="st"> </span><span class="kw">experimentToTable</span>(</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="dt">experiment.output=</span>E1,</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="dt">parameters.file=</span>parameters,</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="dt">sampling.names=</span><span class="kw">c</span>(<span class="st">&quot;1cm&quot;</span>, <span class="st">&quot;10cm&quot;</span>),</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="dt">R2=</span><span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  )</a></code></pre></div>
<p>Finally, ecological memory features can be extracted from the experiment with <em>extractMemoryFeatures</em> in order to facilitate further analyses, as shown below.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">E1.features &lt;-<span class="st"> </span><span class="kw">extractMemoryFeatures</span>(</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="dt">memory.pattern =</span> E1.df,</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="dt">exogenous.component =</span> <span class="st">&quot;Driver.A&quot;</span>,</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">endogenous.component =</span> <span class="st">&quot;Response&quot;</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  )</a></code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
